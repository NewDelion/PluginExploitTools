using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Net;
using System.Net.Sockets;

namespace PMMPLIB
{
    static class QueryUtilsEx
    {
        public static byte[] ReadToByte(this IEnumerable<byte> buffer, byte target, ref int offset)
        {
            var result = buffer.Skip(offset).TakeWhile(d => d != target).ToArray();
            offset += result.Length + 1;
            return result;
        }

        public static byte[] ReadToNull(this IEnumerable<byte> buffer, ref int offset)
        {
            return ReadToByte(buffer, 0x00, ref offset);
        }

        public static string GetString(this IEnumerable<byte> buffer, Encoding encoding)
        {
            return encoding.GetString(buffer.ToArray());
        }
    }

    public class MCPEQuery
    {
        private IPEndPoint _server;
        public IPEndPoint Server
        {
            get { return _server; }
            private set
            {
                if(value == null)
                    throw new ArgumentNullException("サーバアドレスにnullを指定することはできません");
                _server = value;
            }
        }

        private int _port;
        public int ClientPort
        {
            get { return _port; }
            private set { _port = value; }
        }
        

        public MCPEQuery(IPEndPoint server, int client_port)
        {
            Server = server;
            ClientPort = client_port;
        }

        private UdpClient _client = null;
        private int _sessionId = -1;
        private int _token = -1;
        public Dictionary<string, object> Query()
        {
            using (_client = new UdpClient(_port))
            {
                _sessionId = new Random(Environment.TickCount).Next();
                _client.Client.ReceiveTimeout = 1000;

                processHandshake(out _token);
                Dictionary<string, object> result = null;
                processStatistics(out result);

                return result;
            }
        }

        private int writeBasePayload(MemoryStream ms, int sessionId, byte type)
        {
            // Write RakLib header
            ms.Write(new byte[] { 0xfe, 0xfd }, 0, 2);

            // Write Query type
            ms.WriteByte(type);

            // Write Session ID
            ms.Write(BitConverter.GetBytes(sessionId).Reverse().ToArray(), 0, 4);
            return 7;
        }

        private void send(byte[] payload)
        {
            //Console.WriteLine("Send: " + BitConverter.ToString(payload).Replace("-", ":"));
            _client.Send(payload, payload.Length, _server);
        }
        byte[] receive()
        {
            try
            {
                IPEndPoint remote = null;
                var rec = _client.Receive(ref remote);
                //Console.WriteLine("Receive: " + BitConverter.ToString(rec).Replace("-", ":"));
                return rec;
            }
            catch (SocketException ex)
            {
                if (ex.ErrorCode == (int)SocketError.TimedOut)
                {
                    //Console.WriteLine("Receive: [ Error ] Timeout");
                    return null;
                }
                else
                    throw;
            }
        }

        private void processHandshake(out int token)
        {
            int offset = 0;
            using (var ms = new MemoryStream())
            {
                offset += writeBasePayload(ms, _sessionId, 0x09);
                send(ms.ToArray());

                byte[] rec = null;
                int retry_limit = 10;
                while ((rec = receive()) == null && retry_limit-- > 0) ;
                if (rec == null)
                    throw new Exception("タイムアウトによるリトライ回数が上限に達しました");
                if (rec.Length < 7)// type(1) + sessionId(4) + token(1以上) + null(1)
                    throw new Exception("最低でも7byteあるはずだが。。。");
                var token_array = rec.Skip(5).TakeWhile(d => d != 0x00);

                if (token_array.Any(d => 0x7f < d) || !int.TryParse(Encoding.ASCII.GetString(token_array.ToArray()), out token))
                    throw new Exception("受信したトークン文字列の形式が不正です");
            }
        }

        private void processStatistics(out Dictionary<string, object> result)
        {
            int offset = 0;
            using (var ms = new MemoryStream())
            {
                offset += writeBasePayload(ms, _sessionId, 0x00);
                ms.Write(BitConverter.GetBytes(_token).Reverse().ToArray(), 0, 4); offset += 4;
                // Padding for LongData
                ms.Write(new byte[] { 0xff, 0xff, 0xff, 0xff }, 0, 4);
                send(ms.ToArray());

                byte[] rec = null;
                int retry_limit = 5;
                while ((rec = receive()) == null && retry_limit-- > 0) ;
                if (rec == null)
                    throw new Exception("タイムアウトによるリトライ回数が上限に達しました");
                if (rec.Length < 7)
                    throw new Exception("最低でも7byteあるはずだが。。。");

                result = new Dictionary<string, object>();
                offset = 5;// type(1) + sessionId(4)
                while (offset < rec.Length)
                {
                    var key = rec.ReadToNull(ref offset);
                    if (key.Length == 0)
                    {
                        var tmp = rec.ReadToNull(ref offset);
                        if (tmp.GetString(Encoding.UTF8) == (char)0x01 + "player_")
                        {
                            ++offset;
                            var player_list = new List<string>();
                            while (offset < rec.Length)
                            {
                                var name = rec.ReadToNull(ref offset);
                                if (name.Length == 0)
                                    break;
                                player_list.Add(name.GetString(Encoding.UTF8));
                            }
                            result.Add("player_", player_list.ToArray());
                        }
                        else if (offset < rec.Length)//まだ読み取れるデータがある
                            throw new Exception("不正なクエリデータ形式");
                    }
                    else if (key.GetString(Encoding.UTF8) == "plugins")
                    {
                        var plugins_str = rec.ReadToNull(ref offset).GetString(Encoding.UTF8);
                        int plugins_start_index = plugins_str.IndexOf(':');
                        if (plugins_start_index == -1)
                            result.Add("plugins", new string[0]);
                        else
                        {
                            plugins_str = plugins_str.Substring(plugins_start_index + 1);
                            result.Add("plugins", plugins_str.Split(';').Select(p => p.Trim()).ToArray());
                        }
                    }
                    else
                    {
                        result.Add(key.GetString(Encoding.UTF8), rec.ReadToNull(ref offset).GetString(Encoding.UTF8));
                    }
                }

            }
        }
    }
}
