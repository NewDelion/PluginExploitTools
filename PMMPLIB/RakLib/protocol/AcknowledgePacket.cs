using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using PMMPLIB.Utils.Linq;

namespace PMMPLIB.RakLib.Protocol
{
    public abstract class AcknowledgePacket : Packet
    {
        public abstract byte GetID();

        private List<int> _packets = new List<int>();
        public IEnumerable<int> packets { get { return _packets; } }

        public void AddPacket(int seqNumber)
        {
            _packets.Add(seqNumber);
        }

        public static List<Tuple<int, int>> Slize(List<int> acks)
        {
            //ref MiNET
            List<Tuple<int, int>> ranges = new List<Tuple<int, int>>();
            if (acks.Count == 0) return ranges;

            int start = acks[0];
            int prev = start;

            if (acks.Count == 1)
            {
                ranges.Add(new Tuple<int, int>(start, start));
                return ranges;
            }

            acks.Sort();

            for (int i = 1; i < acks.Count; ++i)
            {
                bool isLast = i + 1 == acks.Count;
                int current = acks[i];

                if (current - prev == 1 && !isLast)
                {
                    prev = current;
                    continue;
                }

                if (current - prev > 1 && !isLast)
                {
                    ranges.Add(new Tuple<int, int>(start, prev));

                    start = current;
                    prev = current;
                    continue;
                }

                if (current - prev == 1 && isLast)
                {
                    ranges.Add(new Tuple<int, int>(start, current));
                }

                if (current - prev > 1 && isLast)
                {
                    if (prev == start)
                    {
                        ranges.Add(new Tuple<int, int>(start, current));
                    }
                    if (prev != start)
                    {
                        ranges.Add(new Tuple<int, int>(start, prev));
                        ranges.Add(new Tuple<int, int>(current, current));
                    }
                }
            }

            return ranges;
        }

        public void Encode(System.IO.MemoryStream stream)
        {
            stream.WriteByte(GetID());
            var ranges = Slize(_packets);
            stream.WriteInt16BE((short)ranges.Count);
            foreach (var range in ranges)
            {
                byte singleEntry = (byte)(range.Item1 == range.Item2 ? 0x10 : 0x00);
                stream.WriteByte(singleEntry);
                stream.WriteInt24(range.Item1);
                if(singleEntry == 0)
                    stream.WriteInt24(range.Item2);
            }
        }

        public void Decode(System.IO.MemoryStream stream)
        {
            stream.ReadByte();//id
            short count = stream.ReadInt16BE();
            List<Tuple<int, int>> ranges = new List<Tuple<int, int>>();
            for (int i = 0; i < count; ++i)
            {
                var singleEntry = stream.ReadByte();
                var start = stream.ReadInt24();
                if (singleEntry == 0)
                {
                    var end = stream.ReadInt24();
                    ranges.Add(new Tuple<int, int>(start, end));
                }
                else
                {
                    ranges.Add(new Tuple<int, int>(start, start));
                }
            }
            //UnSlize
            foreach (var range in ranges)
            {
                if (range.Item1 == range.Item2)
                    _packets.Add(range.Item1);
                else
                    for (int i = range.Item1; i <= range.Item2; ++i)
                        _packets.Add(i);
            }
        }
    }
}
