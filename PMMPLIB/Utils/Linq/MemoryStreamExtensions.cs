using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Net;

namespace PMMPLIB.Utils.Linq
{
    public static class StreamExtensions
    {
        public static void Write(this MemoryStream ms, byte[] buffer)
        {
            ms.Write(buffer, 0, buffer.Length);
        }

        public static void WriteInt16(this MemoryStream ms, short target)
        {
            ms.Write(BitConverter.GetBytes(target), 0, 2);
        }

        public static void WriteInt16BE(this MemoryStream ms, short target)
        {
            ms.WriteInt16(Swap.SwapInt16(target));
        }

        public static void WriteInt24(this MemoryStream ms, int target)
        {
            ms.Write(BitConverter.GetBytes(target), 0, 3);
        }

        public static void WriteInt24BE(this MemoryStream ms, int target)
        {
            ms.Write(BitConverter.GetBytes(Swap.SwapInt32(target)), 1, 3);
        }

        public static void WriteInt32(this MemoryStream ms, int target)
        {
            ms.Write(BitConverter.GetBytes(target), 0, 4);
        }

        public static void WriteInt32BE(this MemoryStream ms, int target)
        {
            ms.Write(BitConverter.GetBytes(Swap.SwapInt32(target)), 0, 4);
        }

        public static void WriteInt64(this MemoryStream ms, long target)
        {
            ms.Write(BitConverter.GetBytes(target), 0, 8);
        }

        public static void WriteInt64BE(this MemoryStream ms, long target)
        {
            ms.Write(BitConverter.GetBytes(Swap.SwapInt64(target)), 0, 8);
        }

        public static void WriteAddress(this MemoryStream ms, IPEndPoint address)
        {
            if (address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
            {
                ms.WriteByte(0x04);
                ms.WriteInt32(unchecked((int)~address.Address.Address));
                ms.WriteInt24BE(address.Port);
            }
            else
            {
                //TODO: IPv6
            }
        }

        public static void WriteString(this MemoryStream ms, string target)
        {
            ms.WriteInt16BE((short)target.Length);//checked
            ms.Write(Encoding.UTF8.GetBytes(target));
        }

        public static byte[] ReadBytes(this MemoryStream ms, int length)
        {
            byte[] buf = new byte[Math.Min((ms.Length - ms.Position), length)];
            ms.Read(buf, 0, buf.Length);
            return buf;
        }

        public static short ReadInt16(this MemoryStream ms)
        {
            var tmp = ms.ReadBytes(2);
            if (tmp.Length < 2) throw new ArgumentOutOfRangeException("読み取り可能なデータが足りません");
            return BitConverter.ToInt16(tmp, 0);
        }

        public static short ReadInt16BE(this MemoryStream ms)
        {
            return Swap.SwapInt16(ms.ReadInt16());
        }

        public static int ReadInt24(this MemoryStream ms)
        {
            var tmp = ms.ReadBytes(3);
            if (tmp.Length < 3) throw new ArgumentOutOfRangeException("読み取り可能なデータが足りません");

            //ummmm...
            var tmp1 = new byte[4];
            Buffer.BlockCopy(tmp, 0, tmp1, 0, 3);
            return BitConverter.ToInt32(tmp1, 0);
        }

        public static int ReadInt24BE(this MemoryStream ms)
        {
            var tmp = ms.ReadBytes(3);
            if (tmp.Length < 3) throw new ArgumentOutOfRangeException("読み取り可能なデータが足りません");

            //ummmm...
            var tmp1 = new byte[4];
            var tmp2 = tmp[0];
            tmp[0] = tmp[2];
            tmp[2] = tmp2;
            Buffer.BlockCopy(tmp, 0, tmp1, 0, 3);
            return BitConverter.ToInt32(tmp1, 0);
        }

        public static int ReadInt32(this MemoryStream ms)
        {
            var tmp = ms.ReadBytes(4);
            if (tmp.Length < 4) throw new ArgumentOutOfRangeException("読み取り可能なデータが足りません");
            return BitConverter.ToInt32(tmp, 0);
        }

        public static int ReadInt32BE(this MemoryStream ms)
        {
            return Swap.SwapInt32(ms.ReadInt32());
        }

        public static long ReadInt64(this MemoryStream ms)
        {
            var tmp = ms.ReadBytes(8);
            if (tmp.Length < 8) throw new ArgumentOutOfRangeException("読み取り可能なデータが足りません");
            return BitConverter.ToInt64(tmp, 0);
        }

        public static long ReadInt64BE(this MemoryStream ms)
        {
            return Swap.SwapInt64(ms.ReadInt64());
        }

        public static IPEndPoint ReadAddress(this MemoryStream ms)
        {
            //ref MiNET
            var version = ms.ReadByte();

            var address = IPAddress.Any;
            int port = 0;

            if (version == 4)
            {
                var ip = ms.ReadByte() + "." + ms.ReadByte() + "." + ms.ReadByte() + "." + ms.ReadByte();
                address = IPAddress.Parse(ip);
                port = ms.ReadInt16BE();
            }
            else if (version == 6)
            {
                ms.ReadInt16();// Address family
                port = ms.ReadInt16BE();
                ms.ReadInt64();// Flow info
                var addrBytes = ms.ReadBytes(16);
                address = new IPAddress(addrBytes);
            }
            else
            {
                throw new Exception("Wrong IP version. Expected IPv4 or IPv6 but was IPv" + version);
            }

            return new IPEndPoint(address, port);
        }

        public static string ReadString(this MemoryStream ms)
        {
            return Encoding.UTF8.GetString(ms.ReadBytes(ms.ReadInt16BE()));
        }
    }
}
